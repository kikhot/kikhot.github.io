---
sidebar_position: 8
---

**redis 分布式锁，是如何实现的？**

需要结合项目中的业务进行回答，通常情况下，分布式锁使用的场景: 集群情况下的定时任务、抢单、幂等性场景。

抢券场景

![](./image/image_ad9a2a92-fd10-4479-9dc9-acc3a1671513.png)

![](./image/image_4d42dc34-8b13-4df5-ab21-32bff6fbcf52.png)

在集群的情况下，我们是不能使用本地的锁来解决，需要使用外部的锁来解决（即：分布式锁）。

![](./image/image_bdb73372-f3cc-46cb-b25c-134e9697f09a.png)

### 分布式锁处理过程

![](./image/image_8fbecb89-bd8d-40d2-a190-6f45768c72f2.png)

### redis 分布式锁
Redis 实现分布式锁主要利用 Redis 的 setnx 命令。setnx 是 SET if no exists（如果不存在，则 SET）的简写。

具体的使用方式如下：

+ **获取锁：**

![](./image/image_f3a46b60-9d90-4f42-b0ca-73a7a4cbb930.png)

+ **释放锁：**

![](./image/image_12ac19ab-d148-454e-a9af-6d5fda44dc19.png)

获取锁的时候必须设置过期时间。假如没有设置过期时间，则会出现业务超时或服务宕机时，不会自动释放锁，那么这样就会导致其他线程无法获取该锁，导致**死锁**现象。

![](./image/image_8250c565-d89a-42e0-a561-573019ee5d38.png)

那么这个时候面试官可能会接着问：

:::tip[面试场景]

**Redis 实现分布式锁如何合理的控制锁的有效时长？**

有两种方案，

1）根据业务执行时间预估，来设置锁的过期时间（不太靠谱，时间不好控制）

2）给锁续期，我们一开始设置锁的过期时间，再开另外一个线程用来监控，来判断业务到底执行了多久，如果说业务执行时间比较长，则增加当前获得锁的线程持有锁的时长。那么其实有现成的线程已经实现了该技术（即：看门狗）

:::

### redission 实现的分布式锁-执行流程
![](./image/image_f3183f25-51ab-4596-bc41-bb3f28e547a7.png)

**redission 使用的代码如下：**

![](./image/image_13563231-9d47-425f-abbc-1ed9f3211178.png)

### redission 实现的分布式锁-可重入
![](./image/image_abb62595-69da-440f-bfe0-cc244c05b01d.png)

### redission 实现的分布式锁-主从一致性
![](./image/image_7201c189-7d4a-4cd4-8607-a247c6fdfc3c.png)

当 Java 应用通过分布式获取锁的时候，正常情况下，主节点需要把数据同步到从节点。但是，假如主节点还没来得及同步数据就宕机了，那么依据 redis 提供的哨兵模式，会在两个从节点中选出一个节点作为主节点。而当有新的线程请求来之后，会去尝试请求新的主节点来获取锁，而因为之前宕机的 mater 数据没有同步过来，导致新的线程也能够加锁成功，那么这个时候就会出现两个线程同时持有同一把锁的情况（可能出现脏数据的现象）。

![](./image/image_3a15be07-ac88-409b-adfc-85d1260271a1.png)

为了解决上述情况，redis 提供了另外一个锁机制。 RedLock（红锁）：不能旨在一个 redis 实例上创建锁 ，应该是在多个 redis 实例上创建锁（n/2+1），避免在一个 redis 实例上加锁。

![](./image/image_f60d0cf2-cf4c-4a25-ade3-72277e67de39.png)

但是一般不建议使用 RedLock。redis 使用的是 AP 的思想，也就是最终保证一致性。而我们想要使用到强一致性，可以使用 CP 思想的 zookeeper。

### 面试场景
![](./image/image_4146c02e-4902-48fb-9503-0b41c76d2699.png)



:::tip[面试场景]

**面试官:** Redis 分布式锁如何实现?

**候选人:** 嗯，在 redis 中提供了一个命令 **setnx(SET if not exists)**

由于 redis 的单线程的，用了命令之后，只能有一个客户端对某一个 key 设置值，在没有过期或删除 key 的时候是其他客户端是不能设置这个 key 的

**面试官:** 好的，那你如何控制 Redis 实现分布式锁有效时长呢?

**候选人:** 嗯，的确，redis 的 setnx 指令不好控制这个问题，我们当时采用的 redis 的一个框架 redisson 实现的。

在 redisson 中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成的时候，在 redisson 中引入了一个**看门狗**机制，就是说每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了

还有一个好处就是，在高并发下，一个业务有可能会执行很快，先客户 1 持有锁的时候，客户 2 来了以后并不会马上拒绝，它会自选不断尝试获取锁，如果客户 1 释放之后，客户 2 就可以马上持有锁，性能也得到了提升。

**面试官:** 好的，redisson 实现的分布式锁是可重入的吗?

**候选人:** 嗯，**是可以重入的**。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计算上减一。在存储数据的时候采用的 hash 结构，大 key 可以按照自己的业务进行定制，其中小 key 是当前线程的唯一标识，value 是当前线程重入的次数

:::


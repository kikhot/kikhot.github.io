---
sidebar_position: 11
---


主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：

+ 海量数据存储问题
+ 高并发写的问题

使用分片集群可以解决上述问题，分片集群特征：

+ 集群中有多个 master，每个 master 保存不同数据
+ 每个 master 都可以有多个 slave节点
+ master 之间通过 ping 监测彼此健康状态
+ 客户端请求可以访问集群任意节点，最终都会被转发到正确节点

![](./image/image_be293db1-6df4-4edd-970a-4b8f991f96dc.png)

## 分片集群结构-数据读写
Redis 分片集群引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。

![](./image/image_cc93726c-e5ef-4f6f-8086-6466cc9f1a3e.png)

我们可以通过 hash 值来进行 master 节点的写操作，当有多个分片集群的 master 时，我们需要将 key（即上图左边的'name'）进行 hash 计算得到 hash 值，并将 hash 值与 redis 集群中的总 hash 槽进行取模，得到的结果就对应写入的 master 是哪个呢。

当然也可以通过上图右边的方式不计算 key 的 hash 值，而是计算 \{aaa\} 中的 hash 值。

## 面试场景
:::tip[面试场景]

**redis 的分片集群有什么作用？**

+ 集群中有多个 master，每个 master 保存不同的数据
+ 每个 master 都可以有多个 slave 节点
+ master 之间通过 ping 监测彼此健康状态
+ 客户端请求可以访问集群任意节点，最终都会被转发到正确节点

**redis 分片集群中数据是怎么存储和读取的？**

+ redis 分片集群引入了哈希槽的概念，redis 集群有 16384 个哈希槽
+ 将 16384 个插槽分配到不同的实例
+ 读写数据：根据 key 的有效部分计算哈希值，对 16384 取余（有效部分，如果 key 前面有大括号，大括号的内容就是有效部分，如果没有，则以 key 本生做为有效部分）余数做为插槽，寻找插槽所在的实例

:::



:::tip[面试场景]

**面试官：** redis 的分片集群有什么作用

**候选人：** 分片集群主要解决的是，海量数据存储的问题，集群中有多个 master，每个 master 保存不同数据，并且还可以给每个 master 设置多个 slave 节点，就可以继续增大集群的高并发能力。同时每个 master 之间通过 ping 监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点

**面试官：** Redis 分片集群中数据是怎么存储和读取的?

**候选人：**

嗯～，在 redis 集群中是这样的

Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围，key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，通过槽找到对应的节点进行存储。取值的逻辑是一样的

:::
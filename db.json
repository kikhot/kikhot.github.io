{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[],"Cache":[{"_id":"source\\_posts\\面试题-redis-缓存击穿.md","hash":"3b67e01cc439eeac2db9b6bc92bfbe32f88da3c8","modified":1719500632964},{"_id":"source\\_posts\\面试题_redis_缓存穿透.md","hash":"8eb6c9917a062a10cfc8db177d20dd619ce4a802","modified":1719500632964},{"_id":"source\\categories\\index.md","hash":"2ef721a00c7f610858540256161e78ee08c193fd","modified":1719500632964},{"_id":"source\\tags\\index.md","hash":"53b6d742fae60e00615661bed445f27ee4fb2e85","modified":1719500632964},{"_id":"public/categories/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443},{"_id":"public/2024/06/14/面试题-redis-缓存击穿/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443},{"_id":"public/2024/06/13/面试题_redis_缓存穿透/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443},{"_id":"public/archives/2024/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443},{"_id":"public/archives/2024/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443},{"_id":"public/categories/面试题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443},{"_id":"public/categories/面试题/redis/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443},{"_id":"public/tags/面试题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719500879443}],"Category":[{"name":"面试题","_id":"clxxefe500003vstw8hyq22no"},{"name":"redis","parent":"clxxefe500003vstw8hyq22no","_id":"clxxefe510006vstw0el66xot"}],"Data":[],"Page":[{"title":"categories","date":"2024-06-13T09:50:14.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2024-06-13 17:50:14\n---\n","updated":"2024-06-27T15:03:52.964Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clxxefe4w0000vstw0i2k562i","content":"","excerpt":"","more":""},{"title":"tags","date":"2024-06-13T09:50:45.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2024-06-13 17:50:45\n---\n","updated":"2024-06-27T15:03:52.964Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clxxefe4z0002vstwdbr3daff","content":"","excerpt":"","more":""}],"Post":[{"title":"缓存击穿","date":"2024-06-14T05:40:00.000Z","_content":"\n# 缓存击穿\n\n**缓存击穿：** 给某一个 key 设置了过期时间，当 key 过期的时候，恰好这个时间点对这个 key 有大量的并发请求过来，这些并发的请求可能会瞬间把 DB 压垮\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511186393-d6044f58-1487-4a66-a061-c8992539c961.png#averageHue=%23efe7e6&clientId=u3069bed2-f2ac-4&from=paste&height=211&id=ua1a80a98&originHeight=317&originWidth=1450&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=151608&status=done&style=none&taskId=u933e6e76-82ce-4365-a08e-d0fdc435ed9&title=&width=966.6666666666666)\n\n- **解决方案一：** 互斥锁，强一致性，性能差\n- **解决方案二：** 逻辑过期，高可用，性能优，不能保证数据绝对一致\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511793717-85b08149-ce89-44ab-a413-8db909bf685f.png#averageHue=%23b58684&clientId=u3069bed2-f2ac-4&from=paste&height=67&id=FFsMF&originHeight=100&originWidth=899&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=42114&status=done&style=none&taskId=u834f0a82-8a07-4b15-9a7a-83cf7134fac&title=&width=599.3333333333334)\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511767737-552c275c-4d5e-494e-8c7e-749e054dc5cb.png#averageHue=%23ecebea&clientId=u3069bed2-f2ac-4&from=paste&height=501&id=ucae5ee31&originHeight=752&originWidth=1695&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=365954&status=done&style=none&taskId=u6d02727a-13c2-4357-9211-e832b19788d&title=&width=1130)\n\n## 面试场景\n\n> **面试官:** 什么是缓存击穿?怎么解决?  \n>\n> **候选人:**  \n> \n> 嗯!!  \n> 缓存击穿的意思是对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把DB压垮。\n>   \n> 解决方案有两种方式:  \n> - 第一可以使用互斥锁:当缓存失效时，不立即去load db，先使用如Redis的 setnx去设置一个互斥锁，当操作成功返回时再进行load db的操作并回设缓存，否则重试get缓存的方法  \n> - 第二种方案可以设置当前key逻辑过期，大概是思路如下:  \n>   - 在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间\n>   - 当查询的时候，从redis取出数据后判断时间是否过期\n>   - 如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新  \n> \n> 当然两种方案各有利弊:  \n> - 如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题\n> - 如果选择key的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。","source":"_posts/面试题-redis-缓存击穿.md","raw":"---\ntitle: 缓存击穿\ndate: 2024-06-14 13:40:00\ntags:\n    - 面试题\ncategories:\n    - 面试题\n    - redis\n---\n\n# 缓存击穿\n\n**缓存击穿：** 给某一个 key 设置了过期时间，当 key 过期的时候，恰好这个时间点对这个 key 有大量的并发请求过来，这些并发的请求可能会瞬间把 DB 压垮\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511186393-d6044f58-1487-4a66-a061-c8992539c961.png#averageHue=%23efe7e6&clientId=u3069bed2-f2ac-4&from=paste&height=211&id=ua1a80a98&originHeight=317&originWidth=1450&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=151608&status=done&style=none&taskId=u933e6e76-82ce-4365-a08e-d0fdc435ed9&title=&width=966.6666666666666)\n\n- **解决方案一：** 互斥锁，强一致性，性能差\n- **解决方案二：** 逻辑过期，高可用，性能优，不能保证数据绝对一致\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511793717-85b08149-ce89-44ab-a413-8db909bf685f.png#averageHue=%23b58684&clientId=u3069bed2-f2ac-4&from=paste&height=67&id=FFsMF&originHeight=100&originWidth=899&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=42114&status=done&style=none&taskId=u834f0a82-8a07-4b15-9a7a-83cf7134fac&title=&width=599.3333333333334)\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511767737-552c275c-4d5e-494e-8c7e-749e054dc5cb.png#averageHue=%23ecebea&clientId=u3069bed2-f2ac-4&from=paste&height=501&id=ucae5ee31&originHeight=752&originWidth=1695&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=365954&status=done&style=none&taskId=u6d02727a-13c2-4357-9211-e832b19788d&title=&width=1130)\n\n## 面试场景\n\n> **面试官:** 什么是缓存击穿?怎么解决?  \n>\n> **候选人:**  \n> \n> 嗯!!  \n> 缓存击穿的意思是对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把DB压垮。\n>   \n> 解决方案有两种方式:  \n> - 第一可以使用互斥锁:当缓存失效时，不立即去load db，先使用如Redis的 setnx去设置一个互斥锁，当操作成功返回时再进行load db的操作并回设缓存，否则重试get缓存的方法  \n> - 第二种方案可以设置当前key逻辑过期，大概是思路如下:  \n>   - 在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间\n>   - 当查询的时候，从redis取出数据后判断时间是否过期\n>   - 如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新  \n> \n> 当然两种方案各有利弊:  \n> - 如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题\n> - 如果选择key的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。","slug":"面试题-redis-缓存击穿","published":1,"updated":"2024-06-27T15:03:52.964Z","comments":1,"layout":"post","photos":[],"_id":"clxxefe4x0001vstw6ba54j8o","content":"<h1 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h1><p><strong>缓存击穿：</strong> 给某一个 key 设置了过期时间，当 key 过期的时候，恰好这个时间点对这个 key 有大量的并发请求过来，这些并发的请求可能会瞬间把 DB 压垮</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511186393-d6044f58-1487-4a66-a061-c8992539c961.png#averageHue=%23efe7e6&clientId=u3069bed2-f2ac-4&from=paste&height=211&id=ua1a80a98&originHeight=317&originWidth=1450&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=151608&status=done&style=none&taskId=u933e6e76-82ce-4365-a08e-d0fdc435ed9&title=&width=966.6666666666666\" alt=\"image.png\"></p>\n<ul>\n<li><strong>解决方案一：</strong> 互斥锁，强一致性，性能差</li>\n<li><strong>解决方案二：</strong> 逻辑过期，高可用，性能优，不能保证数据绝对一致</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511793717-85b08149-ce89-44ab-a413-8db909bf685f.png#averageHue=%23b58684&clientId=u3069bed2-f2ac-4&from=paste&height=67&id=FFsMF&originHeight=100&originWidth=899&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=42114&status=done&style=none&taskId=u834f0a82-8a07-4b15-9a7a-83cf7134fac&title=&width=599.3333333333334\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511767737-552c275c-4d5e-494e-8c7e-749e054dc5cb.png#averageHue=%23ecebea&clientId=u3069bed2-f2ac-4&from=paste&height=501&id=ucae5ee31&originHeight=752&originWidth=1695&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=365954&status=done&style=none&taskId=u6d02727a-13c2-4357-9211-e832b19788d&title=&width=1130\" alt=\"image.png\"></p>\n<h2 id=\"面试场景\"><a href=\"#面试场景\" class=\"headerlink\" title=\"面试场景\"></a>面试场景</h2><blockquote>\n<p><strong>面试官:</strong> 什么是缓存击穿?怎么解决?  </p>\n<p><strong>候选人:</strong>  </p>\n<p>嗯!!<br>缓存击穿的意思是对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把DB压垮。</p>\n<p>解决方案有两种方式:  </p>\n<ul>\n<li>第一可以使用互斥锁:当缓存失效时，不立即去load db，先使用如Redis的 setnx去设置一个互斥锁，当操作成功返回时再进行load db的操作并回设缓存，否则重试get缓存的方法  </li>\n<li>第二种方案可以设置当前key逻辑过期，大概是思路如下:  <ul>\n<li>在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间</li>\n<li>当查询的时候，从redis取出数据后判断时间是否过期</li>\n<li>如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新</li>\n</ul>\n</li>\n</ul>\n<p>当然两种方案各有利弊:  </p>\n<ul>\n<li>如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题</li>\n<li>如果选择key的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。</li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h1><p><strong>缓存击穿：</strong> 给某一个 key 设置了过期时间，当 key 过期的时候，恰好这个时间点对这个 key 有大量的并发请求过来，这些并发的请求可能会瞬间把 DB 压垮</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511186393-d6044f58-1487-4a66-a061-c8992539c961.png#averageHue=%23efe7e6&clientId=u3069bed2-f2ac-4&from=paste&height=211&id=ua1a80a98&originHeight=317&originWidth=1450&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=151608&status=done&style=none&taskId=u933e6e76-82ce-4365-a08e-d0fdc435ed9&title=&width=966.6666666666666\" alt=\"image.png\"></p>\n<ul>\n<li><strong>解决方案一：</strong> 互斥锁，强一致性，性能差</li>\n<li><strong>解决方案二：</strong> 逻辑过期，高可用，性能优，不能保证数据绝对一致</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511793717-85b08149-ce89-44ab-a413-8db909bf685f.png#averageHue=%23b58684&clientId=u3069bed2-f2ac-4&from=paste&height=67&id=FFsMF&originHeight=100&originWidth=899&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=42114&status=done&style=none&taskId=u834f0a82-8a07-4b15-9a7a-83cf7134fac&title=&width=599.3333333333334\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701511767737-552c275c-4d5e-494e-8c7e-749e054dc5cb.png#averageHue=%23ecebea&clientId=u3069bed2-f2ac-4&from=paste&height=501&id=ucae5ee31&originHeight=752&originWidth=1695&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=365954&status=done&style=none&taskId=u6d02727a-13c2-4357-9211-e832b19788d&title=&width=1130\" alt=\"image.png\"></p>\n<h2 id=\"面试场景\"><a href=\"#面试场景\" class=\"headerlink\" title=\"面试场景\"></a>面试场景</h2><blockquote>\n<p><strong>面试官:</strong> 什么是缓存击穿?怎么解决?  </p>\n<p><strong>候选人:</strong>  </p>\n<p>嗯!!<br>缓存击穿的意思是对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把DB压垮。</p>\n<p>解决方案有两种方式:  </p>\n<ul>\n<li>第一可以使用互斥锁:当缓存失效时，不立即去load db，先使用如Redis的 setnx去设置一个互斥锁，当操作成功返回时再进行load db的操作并回设缓存，否则重试get缓存的方法  </li>\n<li>第二种方案可以设置当前key逻辑过期，大概是思路如下:  <ul>\n<li>在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间</li>\n<li>当查询的时候，从redis取出数据后判断时间是否过期</li>\n<li>如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新</li>\n</ul>\n</li>\n</ul>\n<p>当然两种方案各有利弊:  </p>\n<ul>\n<li>如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题</li>\n<li>如果选择key的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。</li>\n</ul>\n</blockquote>\n"},{"title":"缓存穿透","date":"2024-06-13T09:58:55.000Z","_content":"\n>例：\n>一个 get 请求：api/news/getById/1\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701495343165-a0018281-afc3-44ae-8f20-37d7cbcfa194.png#averageHue=%23fafaf9&clientId=u952a7e35-ccfe-4&from=paste&height=164&id=u08060d4f&originHeight=246&originWidth=1232&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=103875&status=done&style=none&taskId=uaf86987e-0833-499b-a4d2-4e434117183&title=&width=821.3333333333334)\n\n**缓存穿透：** 查询一个**不存在**的数据，mysql 查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库\n\n**解决方案一：** 缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存。\n**优点：** 简单\n**缺点：** 消耗内存，可能会发生不一致的问题\n\n**解决方案二：** 布隆过滤器\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504427479-16450ce3-e05a-4bae-a9a7-b3e74eb74c6a.png#averageHue=%23f5f3f1&clientId=u4cedfadc-8591-4&from=paste&height=209&id=u9661d065&originHeight=313&originWidth=1570&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=158331&status=done&style=none&taskId=u329eca33-6888-4c14-8fab-4595efcdb33&title=&width=1046.6666666666667)\n\n**优点：** 内存占用较少，没有多余 key\n**缺点：** 实现复杂，存在误判\n\n## 布隆过滤器\n**bitmap（位图）：** 相当于是一个以（bit）位为单位的数组，数组中每个元素智能存储二进制数 0 或 1\n**布隆过滤器作用：** 布隆过滤器可以用于检索一个元素是否在一个集合中。\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504639809-cb4cf6b3-7c37-43a3-808c-cd50d504c6c2.png#averageHue=%23e7e5e3&clientId=u4cedfadc-8591-4&from=paste&height=240&id=u466d40c6&originHeight=360&originWidth=1397&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=125768&status=done&style=none&taskId=u94985e7c-a243-4a48-921d-bebb6ceffab&title=&width=931.3333333333334)\n\n但是可能出现误判现象，如下所示：\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504823538-0e7c6556-5696-44d2-a360-fd34408f94a5.png#averageHue=%23f3ebe9&clientId=u4cedfadc-8591-4&from=paste&height=405&id=u8325e47f&originHeight=607&originWidth=1343&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=158816&status=done&style=none&taskId=udebd0c02-7c35-45cd-b7e9-e568224af4f&title=&width=895.3333333333334)\n\n如何解决这个现象呢？我们可以降低误判率来减少误判的可能性。\n**误判率：** 数组越小误判率就越大，数组越大误判率就越小，但是同时带来了更多的内存消耗。\n\n\n## 面试场景\n> **面试官:** 什么是缓存穿透?怎么解决?  \n> **候选人:**  \n> 嗯~~，我想一下  \n> 缓存穿透是指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，可能导致DB挂掉。这种情况大概率是遭到了攻击。  \n>解决方案的话，我们通常都会用布隆过滤器来解决它\n\n> **面试官:** 好的，你能介绍一下布隆过滤器吗?  \n> **候选人:**  \n> 嗯，是这样~  \n> 布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是redisson实现的布隆过滤器。  \n> 它的底层主要是先去初始化一个比较大数组，里面存放的二进制0或1。在一开始都是o，当一个key来了之后经过3次hash计算，模于数组长度找到数据的下标然后把数组中原来的o改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。  \n> 当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。","source":"_posts/面试题_redis_缓存穿透.md","raw":"---\ntitle: 缓存穿透\ndate: 2024-06-13 17:58:55\ntags:\n    - 面试题\ncategories:\n    - 面试题\n    - redis\n---\n\n>例：\n>一个 get 请求：api/news/getById/1\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701495343165-a0018281-afc3-44ae-8f20-37d7cbcfa194.png#averageHue=%23fafaf9&clientId=u952a7e35-ccfe-4&from=paste&height=164&id=u08060d4f&originHeight=246&originWidth=1232&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=103875&status=done&style=none&taskId=uaf86987e-0833-499b-a4d2-4e434117183&title=&width=821.3333333333334)\n\n**缓存穿透：** 查询一个**不存在**的数据，mysql 查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库\n\n**解决方案一：** 缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存。\n**优点：** 简单\n**缺点：** 消耗内存，可能会发生不一致的问题\n\n**解决方案二：** 布隆过滤器\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504427479-16450ce3-e05a-4bae-a9a7-b3e74eb74c6a.png#averageHue=%23f5f3f1&clientId=u4cedfadc-8591-4&from=paste&height=209&id=u9661d065&originHeight=313&originWidth=1570&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=158331&status=done&style=none&taskId=u329eca33-6888-4c14-8fab-4595efcdb33&title=&width=1046.6666666666667)\n\n**优点：** 内存占用较少，没有多余 key\n**缺点：** 实现复杂，存在误判\n\n## 布隆过滤器\n**bitmap（位图）：** 相当于是一个以（bit）位为单位的数组，数组中每个元素智能存储二进制数 0 或 1\n**布隆过滤器作用：** 布隆过滤器可以用于检索一个元素是否在一个集合中。\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504639809-cb4cf6b3-7c37-43a3-808c-cd50d504c6c2.png#averageHue=%23e7e5e3&clientId=u4cedfadc-8591-4&from=paste&height=240&id=u466d40c6&originHeight=360&originWidth=1397&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=125768&status=done&style=none&taskId=u94985e7c-a243-4a48-921d-bebb6ceffab&title=&width=931.3333333333334)\n\n但是可能出现误判现象，如下所示：\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504823538-0e7c6556-5696-44d2-a360-fd34408f94a5.png#averageHue=%23f3ebe9&clientId=u4cedfadc-8591-4&from=paste&height=405&id=u8325e47f&originHeight=607&originWidth=1343&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=158816&status=done&style=none&taskId=udebd0c02-7c35-45cd-b7e9-e568224af4f&title=&width=895.3333333333334)\n\n如何解决这个现象呢？我们可以降低误判率来减少误判的可能性。\n**误判率：** 数组越小误判率就越大，数组越大误判率就越小，但是同时带来了更多的内存消耗。\n\n\n## 面试场景\n> **面试官:** 什么是缓存穿透?怎么解决?  \n> **候选人:**  \n> 嗯~~，我想一下  \n> 缓存穿透是指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，可能导致DB挂掉。这种情况大概率是遭到了攻击。  \n>解决方案的话，我们通常都会用布隆过滤器来解决它\n\n> **面试官:** 好的，你能介绍一下布隆过滤器吗?  \n> **候选人:**  \n> 嗯，是这样~  \n> 布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是redisson实现的布隆过滤器。  \n> 它的底层主要是先去初始化一个比较大数组，里面存放的二进制0或1。在一开始都是o，当一个key来了之后经过3次hash计算，模于数组长度找到数据的下标然后把数组中原来的o改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。  \n> 当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。","slug":"面试题_redis_缓存穿透","published":1,"updated":"2024-06-27T15:03:52.964Z","comments":1,"layout":"post","photos":[],"_id":"clxxefe510009vstw6rnl4b7s","content":"<blockquote>\n<p>例：<br>一个 get 请求：api&#x2F;news&#x2F;getById&#x2F;1</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701495343165-a0018281-afc3-44ae-8f20-37d7cbcfa194.png#averageHue=%23fafaf9&clientId=u952a7e35-ccfe-4&from=paste&height=164&id=u08060d4f&originHeight=246&originWidth=1232&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=103875&status=done&style=none&taskId=uaf86987e-0833-499b-a4d2-4e434117183&title=&width=821.3333333333334\" alt=\"image.png\"></p>\n<p><strong>缓存穿透：</strong> 查询一个<strong>不存在</strong>的数据，mysql 查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p>\n<p><strong>解决方案一：</strong> 缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存。<br><strong>优点：</strong> 简单<br><strong>缺点：</strong> 消耗内存，可能会发生不一致的问题</p>\n<p><strong>解决方案二：</strong> 布隆过滤器</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504427479-16450ce3-e05a-4bae-a9a7-b3e74eb74c6a.png#averageHue=%23f5f3f1&clientId=u4cedfadc-8591-4&from=paste&height=209&id=u9661d065&originHeight=313&originWidth=1570&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=158331&status=done&style=none&taskId=u329eca33-6888-4c14-8fab-4595efcdb33&title=&width=1046.6666666666667\" alt=\"image.png\"></p>\n<p><strong>优点：</strong> 内存占用较少，没有多余 key<br><strong>缺点：</strong> 实现复杂，存在误判</p>\n<h2 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h2><p><strong>bitmap（位图）：</strong> 相当于是一个以（bit）位为单位的数组，数组中每个元素智能存储二进制数 0 或 1<br><strong>布隆过滤器作用：</strong> 布隆过滤器可以用于检索一个元素是否在一个集合中。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504639809-cb4cf6b3-7c37-43a3-808c-cd50d504c6c2.png#averageHue=%23e7e5e3&clientId=u4cedfadc-8591-4&from=paste&height=240&id=u466d40c6&originHeight=360&originWidth=1397&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=125768&status=done&style=none&taskId=u94985e7c-a243-4a48-921d-bebb6ceffab&title=&width=931.3333333333334\" alt=\"image.png\"></p>\n<p>但是可能出现误判现象，如下所示：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504823538-0e7c6556-5696-44d2-a360-fd34408f94a5.png#averageHue=%23f3ebe9&clientId=u4cedfadc-8591-4&from=paste&height=405&id=u8325e47f&originHeight=607&originWidth=1343&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=158816&status=done&style=none&taskId=udebd0c02-7c35-45cd-b7e9-e568224af4f&title=&width=895.3333333333334\" alt=\"image.png\"></p>\n<p>如何解决这个现象呢？我们可以降低误判率来减少误判的可能性。<br><strong>误判率：</strong> 数组越小误判率就越大，数组越大误判率就越小，但是同时带来了更多的内存消耗。</p>\n<h2 id=\"面试场景\"><a href=\"#面试场景\" class=\"headerlink\" title=\"面试场景\"></a>面试场景</h2><blockquote>\n<p><strong>面试官:</strong> 什么是缓存穿透?怎么解决?<br><strong>候选人:</strong><br>嗯~~，我想一下<br>缓存穿透是指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，可能导致DB挂掉。这种情况大概率是遭到了攻击。<br>解决方案的话，我们通常都会用布隆过滤器来解决它</p>\n</blockquote>\n<blockquote>\n<p><strong>面试官:</strong> 好的，你能介绍一下布隆过滤器吗?<br><strong>候选人:</strong><br>嗯，是这样~<br>布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是redisson实现的布隆过滤器。<br>它的底层主要是先去初始化一个比较大数组，里面存放的二进制0或1。在一开始都是o，当一个key来了之后经过3次hash计算，模于数组长度找到数据的下标然后把数组中原来的o改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。<br>当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。</p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>例：<br>一个 get 请求：api&#x2F;news&#x2F;getById&#x2F;1</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701495343165-a0018281-afc3-44ae-8f20-37d7cbcfa194.png#averageHue=%23fafaf9&clientId=u952a7e35-ccfe-4&from=paste&height=164&id=u08060d4f&originHeight=246&originWidth=1232&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=103875&status=done&style=none&taskId=uaf86987e-0833-499b-a4d2-4e434117183&title=&width=821.3333333333334\" alt=\"image.png\"></p>\n<p><strong>缓存穿透：</strong> 查询一个<strong>不存在</strong>的数据，mysql 查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p>\n<p><strong>解决方案一：</strong> 缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存。<br><strong>优点：</strong> 简单<br><strong>缺点：</strong> 消耗内存，可能会发生不一致的问题</p>\n<p><strong>解决方案二：</strong> 布隆过滤器</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504427479-16450ce3-e05a-4bae-a9a7-b3e74eb74c6a.png#averageHue=%23f5f3f1&clientId=u4cedfadc-8591-4&from=paste&height=209&id=u9661d065&originHeight=313&originWidth=1570&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=158331&status=done&style=none&taskId=u329eca33-6888-4c14-8fab-4595efcdb33&title=&width=1046.6666666666667\" alt=\"image.png\"></p>\n<p><strong>优点：</strong> 内存占用较少，没有多余 key<br><strong>缺点：</strong> 实现复杂，存在误判</p>\n<h2 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h2><p><strong>bitmap（位图）：</strong> 相当于是一个以（bit）位为单位的数组，数组中每个元素智能存储二进制数 0 或 1<br><strong>布隆过滤器作用：</strong> 布隆过滤器可以用于检索一个元素是否在一个集合中。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504639809-cb4cf6b3-7c37-43a3-808c-cd50d504c6c2.png#averageHue=%23e7e5e3&clientId=u4cedfadc-8591-4&from=paste&height=240&id=u466d40c6&originHeight=360&originWidth=1397&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=125768&status=done&style=none&taskId=u94985e7c-a243-4a48-921d-bebb6ceffab&title=&width=931.3333333333334\" alt=\"image.png\"></p>\n<p>但是可能出现误判现象，如下所示：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/40379251/1701504823538-0e7c6556-5696-44d2-a360-fd34408f94a5.png#averageHue=%23f3ebe9&clientId=u4cedfadc-8591-4&from=paste&height=405&id=u8325e47f&originHeight=607&originWidth=1343&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=158816&status=done&style=none&taskId=udebd0c02-7c35-45cd-b7e9-e568224af4f&title=&width=895.3333333333334\" alt=\"image.png\"></p>\n<p>如何解决这个现象呢？我们可以降低误判率来减少误判的可能性。<br><strong>误判率：</strong> 数组越小误判率就越大，数组越大误判率就越小，但是同时带来了更多的内存消耗。</p>\n<h2 id=\"面试场景\"><a href=\"#面试场景\" class=\"headerlink\" title=\"面试场景\"></a>面试场景</h2><blockquote>\n<p><strong>面试官:</strong> 什么是缓存穿透?怎么解决?<br><strong>候选人:</strong><br>嗯~~，我想一下<br>缓存穿透是指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，可能导致DB挂掉。这种情况大概率是遭到了攻击。<br>解决方案的话，我们通常都会用布隆过滤器来解决它</p>\n</blockquote>\n<blockquote>\n<p><strong>面试官:</strong> 好的，你能介绍一下布隆过滤器吗?<br><strong>候选人:</strong><br>嗯，是这样~<br>布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是redisson实现的布隆过滤器。<br>它的底层主要是先去初始化一个比较大数组，里面存放的二进制0或1。在一开始都是o，当一个key来了之后经过3次hash计算，模于数组长度找到数据的下标然后把数组中原来的o改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。<br>当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clxxefe4x0001vstw6ba54j8o","category_id":"clxxefe500003vstw8hyq22no","_id":"clxxefe510007vstwayp0a7ag"},{"post_id":"clxxefe4x0001vstw6ba54j8o","category_id":"clxxefe510006vstw0el66xot","_id":"clxxefe510008vstwds7a7t3o"},{"post_id":"clxxefe510009vstw6rnl4b7s","category_id":"clxxefe500003vstw8hyq22no","_id":"clxxefe52000bvstwhqkh118r"},{"post_id":"clxxefe510009vstw6rnl4b7s","category_id":"clxxefe510006vstw0el66xot","_id":"clxxefe52000cvstw4orm6ox0"}],"PostTag":[{"post_id":"clxxefe4x0001vstw6ba54j8o","tag_id":"clxxefe500004vstw7hh5byeg","_id":"clxxefe510005vstwaxd011ni"},{"post_id":"clxxefe510009vstw6rnl4b7s","tag_id":"clxxefe500004vstw7hh5byeg","_id":"clxxefe52000avstwhnh6a8fx"}],"Tag":[{"name":"面试题","_id":"clxxefe500004vstw7hh5byeg"}]}}